#+title: Emacs configuration
#+property: header-args  :mkdirp yes
#+property: header-args+ :tangle-mode (identity #o444)
#+property: header-args+ :noweb yes
#+PROPERTY: header-args+ :padline no

[[https://www.gnu.org/software/emacs/][GNU Emacs]] is an extensible, customizable, [[https://www.gnu.org/philosophy/free-sw.html][free/libre]] text editor. It is an interpreter for Emacs Lisp, a dialect of the Lisp programming language with extensions to support text editing.

Why lexical scope? https://nullprogram.com/blog/2016/12/22/

This section contains the configuration to be used for pure Emacs (no starter kits).

* Early init file
:properties:
:header-args+: :tangle "emacs/.emacs.d/early-init.el"
:header-args+: :shebang ";; -*- mode: emacs-lisp; lexical-binding: t; -*-"
:end:

Emacs 27+ introduces =early-init.el=, which is run before =init.el=, before package and UI initialization happens. Therefore we can customize in it variables that affect frame appearance as well as the package initialization process.

** Improve garbage collection

The [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Garbage-Collection.html][garbage collection]] in Emacs is very simple. You allocate some bytes and once you pass a certain threshold, it garbage collects.

It turns out that the default behavior is to garbage collect very often. And because there is so little garbage to collect each time, you will not notice any lag. The problem is when you use memory-intensive features like =helm= on a large collection. The solution is mentioned in the manual:

#+begin_example
The initial threshold value is GC_DEFAULT_THRESHOLD, defined in alloc.c. Since it's defined in word_size units, the value is 400,000 for the default 32-bit configuration and 800,000 for the 64-bit one. If you specify a larger value, garbage collection will happen less often. This reduces the amount of time spent garbage collecting, but increases total memory use. You may want to do this when running a program that creates lots of Lisp data. 
#+end_example

*** Defer garbage collection further back in the startup process

The Garbage Collector eats up quite a bit of time, easily doubling startup time. The trick is to turn up the memory threshold as early as possible. This helps reduce initialization time.

#+begin_src emacs-lisp
(customize-set-variable 'gc-cons-threshold most-positive-fixnum)
(customize-set-variable 'gc-cons-percentage 0.6)
#+end_src

*** Set =gc-cons-threshold= smaller for interactive use

I first define a new threshold for triggering the collector:
#+begin_src emacs-lisp
(defvar startup/gc-cons-threshold 67108864 ; 64mb
  "The default value to use for `gc-cons-threshold'.
If you experience freezing, decrease this. If you experience stuttering, increase this.")
#+end_src

We also define a function to be hooked in the startup:
#+begin_src emacs-lisp
(defun startup/reset-gc ()
  (setq gc-cons-threshold startup/gc-cons-threshold
        gc-cons-percentage 0.1))
#+end_src

*** Avoid Garbage Collect When Using Minibuffer

#+begin_src emacs-lisp
(defun gc-minibuffer-setup-hook ()
  (setq gc-cons-threshold (* startup/gc-cons-threshold 2)))

(defun gc-minibuffer-exit-hook ()
  (garbage-collect)
  (setq gc-cons-threshold startup/gc-cons-threshold))
#+end_src

Therefore, while the minibuffer is open, garbage collection will never occur, but once we make a selection, or cancel, garbage collection will kick off immediately and then revert back to the default, sensible behavior. This should fix any random freezing within Emacs.

** Unset =file-name-handler-alist=

Every file opened and loaded by Emacs will run through this list to check for a proper handler for the file, but during startup, it won’t need any of them.

Since the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Magic-File-Names.html][manual]] says that the main use case for this is for accessing remote file (which I never need), I can safely disable it.

#+begin_src emacs-lisp
(defvar startup/file-name-handler-alist file-name-handler-alist 
  "Original alist of elements (REGEXP . HANDLER) for file names handled specially (magic files).")
(setq file-name-handler-alist nil)
#+end_src

#+begin_src emacs-lisp
(defun startup/revert-file-name-handler-alist ()
  (setq file-name-handler-alist startup/file-name-handler-alist))
#+end_src

** Disable =site-run-file=

Since I'm not using a multi-user environment, I can disable it.

#+begin_src emacs-lisp
(setq site-run-file nil)
#+end_src

** Remove the splash startup screen

#+begin_src emacs-lisp
(customize-set-variable 'inhibit-splash-screen t)
#+end_src

** Remove the menu bar

You can always use =F10= to open the menu.

#+begin_src emacs-lisp
(customize-set-variable 'menu-bar-mode nil)
#+end_src

** Remove the tool bar

#+begin_src emacs-lisp
(customize-set-variable 'tool-bar-mode nil)
#+end_src

** Remove the scroll bar

#+begin_src emacs-lisp
(customize-set-variable 'scroll-bar-mode nil)
#+end_src

** Do not activate installed packages when Emacs starts

#+begin_src emacs-lisp
(customize-set-variable 'package-enable-at-startup nil)
#+end_src

** Load custom configuration

Emacs =custom= facility puts some "cryptic" entries into the =custom-set-variables= and =custom-set-faces= in the end of =init.el= file, which I have under version control. This causes a lot of conflicts when I update configuration across different machines.

This code offloads the =custom-set-variables= to a separate file. This keeps your =init.el= neater and you have the option to gitignore your =custom.el= if you see fit.

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))

;; Load custom file. Don't hide errors. Hide success message
(if (file-exists-p custom-file)
  (load custom-file nil t))
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
#+end_src

** Startup hooks

This hook runs after loading init files and handling the command line.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook 'startup/revert-file-name-handler-alist)
(add-hook 'emacs-startup-hook 'startup/reset-gc)
(add-hook 'minibuffer-setup-hook #'gc-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'gc-minibuffer-exit-hook)
;;  Garbage Collect When Emacs is Out of Focus
(add-hook 'emacs-startup-hook
          (lambda ()
            (if (boundp 'after-focus-change-function)
                (add-function :after after-focus-change-function
                              (lambda ()
                                (unless (frame-focus-state)
                                  (garbage-collect))))
              (add-hook 'after-focus-change-function 'garbage-collect))))
#+end_src

* Init file

#+begin_src emacs-lisp :tangle "emacs/.emacs.d/init.el" :shebang ";; -*- mode: emacs-lisp; lexical-binding: t; -*-"
<<sane-ui-defaults>>
<<package-management>>
<<theme>>
<<enable-which-key>>
#+end_src

When Emacs is started, it normally tries to load a Lisp program from an initialization file, or init file for short. This file, if it exists, specifies how to initialize Emacs for you.

** Sane defaults
:properties:
:header-args+: :noweb-ref sane-ui-defaults
:end:

*** Smooth Scrolling
**** Scroll one line at a time

  This is less "jumpy" than the default behaviour.

  #+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
  #+end_src

**** Don't accelerate scrolling

  The original behaviour is to scroll as fast as the user moves the wheel.

  #+begin_src emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
  #+end_src

**** Scroll window under mouse

  Ensure that the mouse wheel scroll the window the mouse is over.

  #+begin_src emacs-lisp
  (setq mouse-wheel-follow-mouse 't)
  #+end_src

**** Keyboard scroll one line at a time

  #+begin_src emacs-lisp
  (setq scroll-step 1)
  #+end_src

**** Scroll window up/down by one line

  Taken from [[http://pragmaticemacs.com/emacs/scrolling-and-moving-by-line/][here]]:
  #+begin_src emacs-lisp
  (global-set-key (kbd "M-n") (kbd "C-u 1 C-v"))
  (global-set-key (kbd "M-p") (kbd "C-u 1 M-v"))
  #+end_src

**** Pixel scrolling                                       :testing:document:

  #+begin_src emacs-lisp
  (setq pixel-scroll-mode t)
  #+end_src

*** Change "yes or no" to "y or n"

  Lazy people like me never want to type "yes" when "y" will suffice.

  #+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  #+end_src

*** Show matching brackets

  [[https://www.emacswiki.org/emacs/ShowParenMode][show-paren-mode]] allows one to see matching pairs of parentheses and other characters. 
  #+begin_src emacs-lisp
  (show-paren-mode 1)
  #+end_src

  By default, there’s a small delay before showing a matching parenthesis. It can be deactivated with the following:
  #+begin_src emacs-lisp
  (setq show-paren-delay 0)
  #+end_src

*** Disable bell sound

  #+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
  #+end_src

*** Change backup behaviour

  This is one of the things people usually want to change right away. By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

  #+begin_src emacs-lisp
  ;; Don't litter my filesystem tree
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/")))
  #+end_src

  Since disk space is cheap, I prefer to save a lot!
  #+begin_src emacs-lisp
  (setq backup-by-copying t) ;; don't clobber symlinks
  (setq delete-old-versions t)
  (setq kept-new-versions 8)
  (setq kept-old-versions 4)
  (setq version-control t)
  #+end_src

*** Save minibuffer history

  #+begin_src emacs-lisp
  (savehist-mode 1)
  #+end_src

*** Add my elisp directory and other files

  Sometimes I load files outside the package system. As long as they're in a directory in my =load-path=, Emacs can find them. 

  #+begin_src emacs-lisp :noweb-ref add-elisp-folder
  (add-to-list 'load-path "~/.elisp")
  #+end_src

*** Line numbering

  Line numbering is really helpful for simple file movement.

**** Number of columns reserved for line number display

  #+begin_src emacs-lisp
  (setq-default display-line-numbers-width 4)
  #+end_src

**** Do not shrink line number width

  #+begin_src emacs-lisp
  (setq display-line-numbers-grow-only t)
  #+end_src

**** Relative line numbers taking into account screen lines

  #+begin_src emacs-lisp
  (setq-default display-line-numbers-type 'visual)
  #+end_src

**** Display the absolute number of the current line

  #+begin_src emacs-lisp
  (setq-default display-line-numbers-current-absolute t)
  #+end_src

**** Disregard narrowing when showing line numbers

  #+begin_src emacs-lisp
  (setq-default display-line-numbers-widen t)
  #+end_src

**** Keybinding for toggling

  The default is no line numbers. One can then toggle with =<f9>=.

  #+begin_src emacs-lisp
  (global-display-line-numbers-mode)
  (global-set-key (kbd "<f9>") 'display-line-numbers-mode)
  #+end_src

**** Show cursor position within line

  #+begin_src emacs-lisp
  (column-number-mode 1)
  #+end_src

*** Setup visual lines

  Visual line mode actually does several things. From a user's point of view, it:
  - Makes lines wrap at word boundaries. (controlled by var truncate-lines and word-wrap.)
  - Makes up/down arrow keys move by a visual line. (controlled by the var line-move-visual.)
  - Makes the kill-line command delete by a visual line, as opposed to a logical line.
  - Turns off the display of little return arrow at the edge of window. (controlled by the var fringe-indicator-alist.)

  Enable by default:
  #+begin_src emacs-lisp
  (global-visual-line-mode t)
  #+end_src

  and this code enable a visual hint whether a paragraph is hard or soften wrapped:
  #+begin_src emacs-lisp
  (defface my-custom-curly-face
    '((t (:foreground "orange")))
    "Face for fringe curly bitmaps."
    :group 'basic-faces)
  (setq-default left-fringe-width 10)
  (set-fringe-bitmap-face 'left-curly-arrow 'my-custom-curly-face)
  (set-fringe-bitmap-face 'right-curly-arrow 'my-custom-curly-face)
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
  #+end_src

** Package management
:properties:
:header-args+: :noweb-ref package-management
:end:

Nowadays almost nobody uses Emacs without a pile of plugins/addons. Manage those addons is a pain in the ass. Fortunately Emacs 24 introduced a new tool, =package.el= to make this management a little easier.

By using the [[https://github.com/jwiegley/use-package][use-package]] macro one can isolate package configuration in your initialization files in a way that is both performance-oriented and tidy. It is a tool that streamlines the configuration of packages. handles everything from assigning key bindings, setting the value of customisation options, writing hooks, declaring a package as a dependency for another, and so on. 

Though it might not be readily apparent, a "package" in Emacs parlance is any elisp file that is evaluated by Emacs.  This includes libraries that are shipped with the upstream distribution as well as code that comes from other sources.

As such =use-package= is *NOT* a package manager, in the sense of installing, removing, listing packages.  It only configures things using a declarative syntax.  The package manager of Emacs is =package.el= while there are other tools available from third parties, such as =straight.el=.

I’ve been using [[https://github.com/raxod502/straight.el][straight.el]] for package management for a while and I really like it.

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

We can integrate it with =use-package=:
#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
(straight-use-package 'use-package)
#+end_src

** Make Emacs discoverable
:properties:
:header-args+: :noweb-ref enable-which-key
:end:

Emacs by default is built around this idea of discoverability. It is a self-documented editor. To see this, check =C-h ?=.

However, after enabling a whole plethora of available packages you can get lost by the messiness of the enabled shortcuts.

[[https://github.com/justbur/emacs-which-key][which-key]] is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup. This provides a way to discover shortcuts globally.

Most of the time I want the which-key popup only when I need it. This will prevent which-key from showing automatically, and allow you to use =C-h= in the middle of a key sequence to show the which-key buffer and keep it open for the remainder of the key sequence.

#+begin_src emacs-lisp
(use-package which-key
  :config
  ;; Allow C-h to trigger which-key before it is done automatically
  (setq which-key-show-early-on-C-h t)
  ;; make sure which-key doesn't show normally but refreshes quickly after it is
  ;; triggered.
  (setq which-key-idle-delay 10000)
  (setq which-key-idle-secondary-delay 0.05)
  (which-key-mode))
#+end_src

** Make Emacs sexy
:properties:
:header-args+: :noweb-ref theme
:end:

*** Doom themes

#+begin_src emacs-lisp
(use-package doom-themes
  :config
  ;; Global settings (defaults)
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled
  (load-theme 'doom-one t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)

  ;; Enable custom neotree theme (all-the-icons must be installed!)
  (doom-themes-neotree-config)
  ;; or for treemacs users
  (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
  (doom-themes-treemacs-config)

  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+end_src
