#+TITLE: Zsh configuration

[[http://www.zsh.org/][Zsh]] is an extended Bourne shell designed for interactive use, although it is also a powerful scripting language. Since Zsh can be considered as "bash on steroids", most of the following configuration comes from [[./bash.org]]

** =zshrc=
:PROPERTIES:
:TANGLE: zsh/.zshrc
:PADLINE: no
:MKDIRP: yes
:END:

This file is a shell script that Zsh runs whenever it is started interactively. You can put any command in that file that you could type at the command prompt. This is the place where you can set up variables, functions and aliases, define your (PS1) prompt and define other settings that you want to use every start you open a new terminal window

*** Theme for =ls=

I like a lot [[http://ethanschoonover.com/solarized][solarized]] colorscheme, so I was lucky to find [[https://github.com/seebi/dircolors-solarized][this]].

#+BEGIN_SRC sh
eval `dircolors ${HOME}/.dircolors-solarized/dircolors.256dark`
#+END_SRC

*** Path configuration
**** Special folders
***** =0.Inbox=

Unprocessed items that don’t have a place yet in here. It is a temporary folder for files you're messing around with but don't need to save long-term. This may be items like software installers you’ve downloaded, files sent to you from colleagues, random text clippings and testing scripts. Files I decide I want to keep graduate from =0.sandbox= to =1.docs=. This folder must be emptied everyday. To avoid procrastination, resulting in a completely cluttered folder, you can keep a 'janitor' script, deleting its contents regularly.

#+BEGIN_SRC sh
INBOX=${HOME}/0.Inbox/
#+END_SRC

***** =1.Working=

Is the big kahuna [fn:: Kahuna is a Hawaiian word, defined in Pukui & Elbert (1986) as a "priest, sorcerer, magician, wizard, minister, expert in any profession". (See also Ancient Hawaii.) Forty types of kahuna are listed in the book Tales from the Night Rainbow.] of all directories. It's the place where all the working files for your currently in-progress tasks, projects and clients go. Each project gets its own unique directory. You may have many sub-folders in this directory, but (to keep you sanity) don't go deeper than 3 subfolders. This directory changes often and frequently, so you must clean it regularly. Because of this most of the files here are kept under github/gitlab control.

#+BEGIN_SRC sh
DOCS=${HOME}/1.Working/
#+END_SRC

***** =2.Archive=

Completed projects, general reference items, and anything else which is important and you might want to look at again go here. From here you can create aliases for the default folder from your system, like 'Books' or 'Pictures'.  The files here don't change much if ever, and so you can back them up on a different (less frequent) schedule. Therefore I elected this folder to be actually a symbolic link to my Dropbox folder.

#+BEGIN_SRC sh
ARCHIVE=${HOME}/2.Archive/
#+END_SRC

***** =3.Media=

Multimedia files (games, pictures and movies). This is a file that usually I don't mind to keep a backup.

#+BEGIN_SRC sh
ARCHIVE=${HOME}/3.Media/
#+END_SRC

***** =4.Opt=

Third-party software, not present among the official packages.

#+BEGIN_SRC sh
OPT=${HOME}/4.Opt
#+END_SRC

***** =$PATH= variable

The =PATH= environment variable is a colon-delimited list of directories that your shell searches through when you enter a command.

Program files (executables) are kept in many different places on the Unix system. Your =PATH= tells the Unix shell where to look on the system when you request a particular program. Having more directories in your path will reduce the number of times you get "Command not found" errors, but might put you at greater risk of activating a Trojan horse.

Most of my additional commands/scripts remain centralized in =${HOME}/4.Opt/bin=, which I link to =${HOME}/.bin=.

#+BEGIN_SRC sh
export PATH=${OPT}/bin:${HOME}/.local/bin:${PATH}
#+END_SRC

*** Shell options
**** Path to oh-my-zsh

#+BEGIN_SRC sh
export ZSH=${HOME}/.oh-my-zsh
#+END_SRC

**** Theme for zsh

#+BEGIN_SRC sh
ZSH_THEME="agnoster"
#+END_SRC

**** Case sensitive completion

#+BEGIN_SRC sh
CASE_SENSITIVE="true"
#+END_SRC

**** Red dots while waiting completion

#+BEGIN_SRC sh
COMPLETION_WAITING_DOTS="true"
#+END_SRC

**** Zsh plugins

#+BEGIN_SRC sh
plugins=(git archlinux python tmux virtualenvwrapper)
source $ZSH/oh-my-zsh.sh
#+END_SRC

*** Aliases
**** Archive Extracter

Linux provides various tools for archiving and compressing files such as [[https://en.wikipedia.org/wiki/Zip_(file_format)][zip]], [[https://en.wikipedia.org/wiki/Bzip2][bzip]], [[https://en.wikipedia.org/wiki/Gzip][gzip]], [[https://en.wikipedia.org/wiki/Tar_(computing)][tar]], [[https://en.wikipedia.org/wiki/RAR_(file_format)][rar]], /etc/. There are more tools that are not native to Linux, but provide good archiving and compressing abilities. With such a large number of tools at hand, sometimes it becomes difficult to remember all the commands. '[[http://www.nongnu.org/atool/][atool]]' allows you to manage these different file archives with a single command.

=ae= is a mnemonic for Archive Extracter.

#+BEGIN_SRC sh
alias ae='aunpack' 
#+END_SRC

**** Colored =ls=

Because sometimes zsh might like to see life in black and white.

#+BEGIN_SRC sh
alias ls="ls --color=always"
#+END_SRC

**** Human readable disk usage

The =df= command displays the amount of disk space available on the file system. However, the default setting is to show the usage in KB, which is quite hard to eye-read.

#+BEGIN_SRC sh
alias df="df -H"
#+END_SRC

**** Human readable file size

The =du= command displays the estimate file space usage. Like =df=, the default setting is to show the usage in KB.

#+BEGIN_SRC sh
alias du="du -h"
#+END_SRC

**** Emacs client

When Emacs have a running server, it is convenient to have this alias defined, instead to type the cumbersome =emacsclient -t= command.

#+BEGIN_SRC sh
alias emacx="emacsclient -t"
#+END_SRC

**** Open dotfiles

Since my dotfiles stay in a fixed place, it is convenient to have an alias to jump in to it.

#+BEGIN_SRC sh
alias dotfiles="cd ${HOME}/.dotfiles"
#+END_SRC

*** Use Neovim as default editor

#+BEGIN_SRC sh
# Preferred editor for local and remote sessions
if [[ -n $SSH_CONNECTION ]]; then
  export EDITOR='vim'
else
  export EDITOR='nvim'
fi
#+END_SRC

