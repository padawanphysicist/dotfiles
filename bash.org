#+title: Bash configuration
#+property: header-args  :mkdirp yes
#+property: header-args+ :tangle-mode (identity #o444)
#+property: header-args+ :noweb yes
#+property: header-args+ :padline no
#+property: header-args+ :tangle "bash/.bashrc"

[[https://www.gnu.org/software/bash/][GNU Bash]] is the GNU Project's shell.

The shell program uses a collection of startup files to help create an environment. Each file has a specific use and may affect /login/ and /interactive/ environment differently.

An /interactive login shell/ is started after a successful login, using =/bin/login=, by reading the =/etc/passwd= file: that is, it's a shell which is started through /authentication/ (name and password). This shell invocation normally reads the following files, in this order, upon start:  =~/.bash_profile=, =~/.bash_login= and =/etc/profile=.

An /interactive non-login shell/ is normally started at the command-line using a shell program (e.g., =[prompt]$/bin/bash=) or by the =/bin/su= command. An interactive non-login shell is also started with a terminal program such as =xterm= or =konsole= from within a graphical environment. This type of shell invocation normally copies the parent environment and then reads the user's =~/.bashrc= file for additional startup configuration instructions.

A /non-interactive shell/ is usually present when a shell script is running. It is non-interactive because it is processing a script and not waiting for user input between commands. For these shell invocations, only the environment inherited from the parent shell is used. 

The configuration is done within a single file (=.bashrc=). Additional configuration can be done by addind them to =.bash_profile=.

* Prompt (PS1)

Bash prompt configuration is contained within the =$PS1= environment variable, which is extremely terse and hard to work with. The following is my =$PS1= configuration:
#+begin_src bash
source "/usr/share/git/git-prompt.sh" # Default when installing Git

# Configure `__git_ps1` to tell us as much as possible
export GIT_PS1_SHOWDIRTYSTATE=1 GIT_PS1_SHOWSTASHSTATE=1 GIT_PS1_SHOWUNTRACKEDFILES=1
export GIT_PS1_SHOWUPSTREAM=verbose GIT_PS1_DESCRIBE_STYLE=branch GIT_PS1_SHOWCOLORHINTS=1
export GIT_PS1_HIDE_IF_PWD_IGNORED=1

# Colorful prompt for Bash!
export PS1='\w\[\e[0;33m\]$(__git_ps1 " (%s)")\[\e[0m\]>> '
 
# Unrelated but useful: avoid auto-edit on successful merges, starting with Git 2.0
export GIT_MERGE_AUTOEDIT=no
#+end_src

* Bash Completion

[[https://github.com/scop/bash-completion][bash-completion]] is a collection of command line command completions for Bash and a collection of helper functions to assist in creating new completions, and set of facilities for loading completions automatically on demand, as well as installing them. Take a look at [[https://repology.org/project/bash-completion/versions][Repology]] for a list of distributions, package names and available versions.

#+begin_src bash
# Use bash-completion, if available
[[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && \
    . /usr/share/bash-completion/bash_completion
#+end_src

* History
** Set history options

Set a shell options to control how history is stored:

- =cmdhist= :: saves all lines in a multi-line command in the history file, which makes it easy to modify multi-line commands that we've run.
- =histreedit= :: allows a user to re-edit a failed history substitution instead of clearing the prompt.
- =histappend= :: append to history, not overwrite it.
- =histverify= :: results of history are not immediately passed to the shell parser. The resulting line is loaded into the Readline editing buffer, allowing modifications. 

#+begin_src bash
shopt -s cmdhist    
shopt -s histreedit 
shopt -s histappend 
shopt -s histverify
#+end_src

** Set history file

Bash has command history support that allows you to recall previously run commands and run them again at a later session. Command history is stored both in memory and in a special file written to disk, =$HOME/.bash_history=.

#+begin_src bash
export HISTFILE="${HOME}/.bash_history"
#+end_src

** Save only a subset of history

When saving command history in memory, I want to prevent two things from being added: 
- =ignorespace= :: lines beginning with whitespace (in case we have a reason to run a command and not remember it);
- =ignoredups= :: duplicate lines (which are just a nuisance to scroll through). 
- =erasedups= :: causes all previous lines matching the current line to be removed from the history list before that line is saved. 

We don't want this environment variable to leak into subshells (especially noninteractive subshells), so we don't =export= it.

#+begin_src bash
HISTCONTROL=ignorespace:ignoredups:erasedups
#+end_src

** Commands to ignore in history

I also ignore too short commands, like =ls= and =pwd=. This is only junk in the history, as it is simple and fast to type.

#+begin_src bash
export HISTIGNORE="?:??:???:$HISTIGNORE"
#+end_src

** Unlimited history

I also like to keep an unlimited history list
#+begin_src bash
export HISTSIZE=-1
export HISTFILESIZE=-1
#+end_src

** Preserve history across tmux sessions

#+begin_src bash
export PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND$'\n'}history -a; history -n; history -c; history -r"
#+end_src
* Colored =ls=

#+begin_src bash
eval "$(dircolors ${HOME}/.dir_colors_256_dark)"
#+end_src
