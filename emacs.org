#+title: Emacs configuration

[[https://www.gnu.org/software/emacs/][GNU Emacs]] is an extensible, customizable, [[https://www.gnu.org/philosophy/free-sw.html][free/libre]] text editor. It is an interpreter for Emacs Lisp, a dialect of the Lisp programming language with extensions to support text editing.

* Init file
:properties:
:header-args:  :tangle "emacs/.emacs"
:header-args+: :tangle-mode (identity #o444)
:header-args+: :mkdirp yes
:header-args+: :shebang ";; -*- mode: emacs-lisp -*-"
:end:

The init file contains personal Emacs-Lisp code that you want to execute when you start Emacs.

** Sane defaults
*** Personal Information

 #+begin_src emacs-lisp
(setq user-full-name "Victor Santos"
      user-mail-address "victor_santos@fisica.ufc.br")
 #+end_src

*** Disable menu-bar, tool-bar, and scroll-bar

 #+begin_src emacs-lisp
(if (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
 #+end_src

*** Cursor style

 I like the cursor similar to other text editors.

 #+begin_src emacs-lisp
(setq-default cursor-type 'bar)
 #+end_src

*** Smooth Scrolling

#+begin_src emacs-lisp
;; Scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
;; don't accelerate scrolling
(setq mouse-wheel-progressive-speed nil)
;; scroll window under mouse
(setq mouse-wheel-follow-mouse 't)
;; keyboard scroll one line at a time
(setq scroll-step 1)
#+end_src

*** Disable startup screen

 #+begin_src emacs-lisp
(setq inhibit-startup-screen t)
 #+end_src

*** Show matching brackets

 =[[https://www.emacswiki.org/emacs/ShowParenMode][show-paren-mode]]= allows one to see matching pairs of parentheses and other characters. 
 #+begin_src emacs-lisp
(show-paren-mode 1)
 #+end_src

 By default, there’s a small delay before showing a matching parenthesis. It can be deactivated with the following:
 #+begin_src emacs-lisp
(setq show-paren-delay 0)
 #+end_src

*** Disable bell sound

 #+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
 #+end_src

*** Set up *scratch* buffer

 #+begin_src emacs-lisp
(setq initial-scratch-message ";; Excuse me sir, do you have a moment to talk about our\n;; Lord, Savior, and the one true operating system, EMACS?")
 #+end_src

*** Change "yes or no" to "y or n"

 Lazy people like me never want to type "yes" when "y" will suffice.

 #+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
 #+end_src

*** Change backup behaviour

 This is one of the things people usually want to change right away. By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

 #+begin_src emacs-lisp
;; Don't litter my filesystem tree
(setq backup-directory-alist '(("." . "~/.emacs.d/backups/")))
 #+end_src

 Since disk space is cheap, I prefer to save a lot!
 #+begin_src emacs-lisp
(setq backup-by-copying t) ;; don't clobber symlinks
(setq delete-old-versions t)
(setq kept-new-versions 8)
(setq kept-old-versions 4)
(setq version-control t)
 #+end_src

*** Package management
**** Setup =package.el=

 Modified from https://melpa.org/#/getting-started:
 #+begin_src emacs-lisp
(require 'package)
(setq package-enable-at-startup nil) ;; Do not activate installed packages when Emacs starts
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl
    (warn "\
Your version of Emacs does not support SSL connections,
which is unsafe because it allows man-in-the-middle attacks.
There are two things you can do about this warning:
1. Install an Emacs version that does support SSL and be safe.
2. Remove this warning from your init file so you won't see it again."))
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (add-to-list 'package-archives (cons "org" (concat proto "://orgmode.org/elpa/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))
(unless package--initialized (package-initialize))
 #+end_src

**** Setup =use-package=

 [[https://jwiegley.github.io/use-package][use-package]] allows to isolate configuration 

 #+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))

;; Causes all packages to be installed automatically if not already
;; present in the system
(setq use-package-always-ensure t)
 #+end_src

*** Load custom configuration

Offload the custom-set-variables to a separate file. This keeps your init.el neater and you have the option to gitignore your custom.el if you see fit.

#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))

;;; Load custom file. Don't hide errors. Hide success message
(load custom-file nil t)
#+end_src

*** Save file with F12

I really dislike the default key chord.

#+begin_src emacs-lisp
(global-set-key (kbd "<f12>") 'save-buffer)
#+end_src

*** Find file with C-o

The keybinding =C-o= is bound to =<insertline>=, which inserts a newline after the cursor. I never use this command, so let us have something more useful.

#+begin_src emacs-lisp
(global-set-key (kbd "C-o") 'helm-find-files)
#+end_src

** Add my elisp directory and other files

Sometimes I load files outside the package system. As long as they're in a directory in my =load-path=, Emacs can find them. 

#+begin_src emacs-lisp
(add-to-list 'load-path "~/.elisp")
#+end_src

** Theme
*** Treat all themes as safe

Do not query the user before use

#+begin_src emacs-lisp
(setf custom-safe-themes t)
#+end_src

*** Download themes

#+begin_src emacs-lisp
;(use-package solarized-theme :demand t)
;(use-package doom-themes :demand t)
(use-package spacemacs-theme :defer t :demand t)
#+end_src

*** Functions for changing themes

#+begin_src emacs-lisp
(defun vct/disable-all-themes ()
  (dolist (th custom-enabled-themes)
          (disable-theme th)))
#+end_src

#+begin_src emacs-lisp
(defun vct/load-dark-theme ()
  (vct/disable-all-themes)
  (load-theme 'spacemacs-dark))
#+end_src

#+begin_src emacs-lisp
(defun vct/load-light-theme ()
  (vct/disable-all-themes)
  (load-theme 'spacemacs-light))
#+end_src

=C-x t= to toggle between light and dark themes:
#+begin_src emacs-lisp
(defun vct/toggle-theme () "Toggle between dark and light themes."
  (interactive)
  ;; Load dark if light is top-most enabled theme, else load light.
  (if (equal (car custom-enabled-themes) 'spacemacs-dark)
      (vct/load-light-theme)
      (vct/load-dark-theme))
  ;; The dark theme's modeline separator is ugly.
  ;; Keep reading below regarding “powerline”.
  ;; (setq powerline-default-separator 'arrow)
  ;; (spaceline-spacemacs-theme)
)

(global-set-key "\C-x\ t" 'vct/toggle-theme)

;; Initially begin with the light theme.
(load-theme 'spacemacs-light t)
#+end_src

I like light on dark because I find it to be more restful. I find hard a theme which works both on GUI and terminal, but so far [[https://github.com/nashamri/spacemacs-theme][Spacemacs theme]] seems to be a nice choice.
#+begin_src emacs-lisp
;; (use-package spacemacs-theme
;;   :defer t
;;   :init
;;   (load-theme 'spacemacs-dark t))
#+end_src

** Spaceline

Powerline theme from Spacemacs

#+begin_src emacs-lisp
(use-package spaceline
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (setq powerline-default-separator 'box)
  (spaceline-compile))
#+end_src

** Clean up modeline

#+begin_src emacs-lisp
(use-package diminish)
#+end_src

** Undo/Redo window configuration

This enable [[https://www.emacswiki.org/emacs/WinnerMode][WinnerMode]]:
#+begin_src emacs-lisp
(when (fboundp 'winner-mode)
      (winner-mode 1))
#+end_src

** Jumping around the file

#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind (("C-;" . avy-goto-char)
         ("M-g g" . avy-goto-line)))
#+end_src

** Jumping around buffers

For this I use the nice [[https://github.com/abo-abo/ace-window][ace-window]] package.

#+begin_src emacs-lisp
(use-package ace-window
  :bind (("M-o" . ace-window)))
#+end_src

I also like to highlight the current buffer:

#+begin_src emacs-lisp
(use-package auto-dim-other-buffers
  :config (auto-dim-other-buffers-mode))

(add-hook 'after-init-hook (lambda ()
  (when (fboundp 'auto-dim-other-buffers-mode)
    (auto-dim-other-buffers-mode t))))
#+end_src

** Make Emacs discoverable

Displays available keybindings in popup, turning Emacs more discoverable.
#+begin_src emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :init
  (which-key-mode)
  :config
  (setq which-key-idle-delay 0.05))
#+end_src

** Completion on steroids

[[https://github.com/emacs-helm/helm][Helm]] is is an Emacs framework for incremental completions and narrowing selections.

#+begin_src emacs-lisp
(use-package helm
  :diminish helm-mode
  :bind (("M-x" . helm-M-x)
         ("C-x C-f" . helm-find-files)
         ("C-x C-r" . helm-recentf)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list))
  :config
  (progn
    (setq helm-buffers-fuzzy-matching t)
    (customize-set-variable 'helm-ff-lynx-style-map t)
    (define-key helm-map (kbd "<left>") 'helm-previous-source)
    (define-key helm-map (kbd "<right>") 'helm-next-source)
    ;; Change back behaviour of TAB completion in =helm-find-files=
    (define-key helm-map (kbd "TAB") 'helm-execute-persistent-action)
    (helm-mode 1)))
#+end_src

I also add [[https://company-mode.github.io/][company-mode]], which is a completion framework for emacs:
#+begin_src emacs-lisp
(use-package company
  :config
  (setq company-tooltip-align-annotations t)
  (setq company-tooltip-flip-when-above t)
  ;; Easy navigation to candidates with M-<n>
  (setq company-show-numbers t)
  (setq company-require-match nil)
  (add-hook 'after-init-hook 'global-company-mode))
#+end_src
** Sane undo/redo

The =undo-tree-mode= replaces Emacs' undo system with a system that treats undo history as a branching tree of changes:

#+begin_src emacs-lisp
(use-package undo-tree
  :init (global-undo-tree-mode)
  :config
  ;; Turn on everywhere
  (global-undo-tree-mode 1)
  ;; Each node in the tree should have a timestamp
  (setq undo-tree-visualizer-timestamps t)
  ;; Show a diff window displaying changes between undo nodes
  (setq undo-tree-visualizer-diff t)
  ;; Make ctrl-z undo
  (global-set-key (kbd "C-z") 'undo)
  ;; Make ctrl-Z redo
  (defalias 'redo 'undo-tree-redo)
  (global-set-key (kbd "C-S-z") 'redo))
#+end_src

** Git configuration

[[https://magit.vc/][Magit]] is a wonderful git interface for emacs

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-x g" . magit-status)))
(use-package git-gutter-fringe
  :config
  (global-git-gutter-mode t))
#+end_src
** LaTeX configuration

#+begin_src emacs-lisp
(use-package tex
  :defer t
  :ensure auctex
  :config
  (setq TeX-auto-save t))
#+end_src

** Spelling

#+begin_src emacs-lisp
(use-package flyspell
  :diminish flyspell-mode
  :hook ((prog-mode . flyspell-prog-mode)
	 (text-mode . flyspell-mode)))

(setq ispell-program-name "/usr/bin/aspell")
(setq ispell-dictionary "en_US") ;; set the default dictionary

(eval-after-load "flyspell"
  ' (progn
     (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
     (define-key flyspell-mouse-map [mouse-3] #'undefined)))

(global-font-lock-mode t)
(custom-set-faces '(flyspell-incorrect ((t (:inverse-video t)))))

(setq ispell-silently-savep t)
#+end_src

** Programming languages
*** Ruby

#+begin_src emacs-lisp
(use-package inf-ruby
  :init
  (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
  :config
  (progn
    (add-to-list 'inf-ruby-implementations '("pry" . "pry"))
    (setq inf-ruby-default-implementation "pry")))
#+end_src

*** R

#+begin_src emacs-lisp
(use-package ess
  :ensure ess
  :commands (inferior-ess-mode ess-help-mode)
  :config
  (setq inferior-R-args "--quiet"))
#+end_src
** Load external plugins

#+begin_src emacs-lisp
(use-package org
  :pin org
  :ensure org-plus-contrib ;; Workaround
  :config
  (require 'user-init-org))
#+end_src

* Org configuration
:properties:
:header-args:  :tangle "emacs/.elisp/user-init-org.el"
:header-args+: :mkdirp yes
:header-args+: :noweb yes
:end:

Org is so awesome it deserves a package itself:
#+begin_src emacs-lisp
;; package --- Summary
;;; configure org mode
;;; Commentary:
;; Configures org mode parameters

;;; Code:

<<org-conf>>

(message "configuring org-mode")
(provide 'user-init-org)
;;; user-init-org.el ends here
#+end_src

** General configuration
:properties:
:header-args+: :noweb-ref org-conf
:header-args+: :tangle no
:end:

*** Ident mode by default

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

*** Visual lines by default

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

*** Fix tag position

#+begin_src emacs-lisp
(setq org-tags-column 0)
#+end_src

*** Stop the org-level headers from increasing in height relative to the other text

#+begin_src emacs-lisp
(defun my/org-mode-hook ()
  "Stop the org-level headers from increasing in height relative to the other text."
  (dolist (face '(org-level-1 org-level-2 org-level-3 org-level-4 org-level-5))
    (set-face-attribute face nil :weight 'normal :height 1.0)))
(add-hook 'org-mode-hook 'my/org-mode-hook)
#+end_src

** LaTeX
:properties:
:header-args+: :noweb-ref org-conf
:header-args+: :tangle no
:end:

*** Fix fragment preview size

Solution from [[https://ipfs-sec.stackexchange.cloudflare-ipfs.com/emacs/A/question/3387.html][here]]:

#+begin_src emacs-lisp
;; Default scaling
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))

(defun update-org-latex-fragments ()
  (org-toggle-latex-fragment '(16))
  (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
    (plist-put org-format-latex-options :scale (* 2.3 text-scale-factor))
    (princ (plist-get org-format-latex-options :scale))
    )
  (org-toggle-latex-fragment '(16)))
(add-hook 'text-scale-mode-hook 'update-org-latex-fragments)
#+end_src

*** Fix fragment preview numbering

In org-mode we can use LaTeX equations, and toggle an overlay that shows what the rendered equation will look like. However, each fragment is created in isolation, meaning that numbering is almost always wrong, and typically with each numbered equation starting with (1). [[http://kitchingroup.cheme.cmu.edu/blog/2016/11/07/Better-equation-numbering-in-LaTeX-fragments-in-org-mode/][This hack]], stolen from John Kitchin, solves this in a nice way for my purposes.

#+begin_src emacs-lisp
(require 'cl-lib)
(require 'cl)
(defun org-renumber-environment (orig-func &rest args)
  "Improve equation numbering"
  (let ((results '())
	(counter -1)
	(numberp))
    (setq results (loop for (begin .  env) in
			(org-element-map (org-element-parse-buffer) 'latex-environment
			  (lambda (env)
			    (cons
			     (org-element-property :begin env)
			     (org-element-property :value env))))
			collect
			(cond
			 ((and (string-match "\\\\begin{equation}" env)
			       (not (string-match "\\\\tag{" env)))
			  (incf counter)
			  (cons begin counter))
			 ((string-match "\\\\begin{align}" env)
			  (prog2
			      (incf counter)
			      (cons begin counter)
			    (with-temp-buffer
			      (insert env)
			      (goto-char (point-min))
			      ;; \\ is used for a new line. Each one leads to a number
			      (incf counter (count-matches "\\\\$"))
			      ;; unless there are nonumbers.
			      (goto-char (point-min))
			      (decf counter (count-matches "\\nonumber")))))
			 (t
			  (cons begin nil)))))
    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
	    (concat
	     (format "\\setcounter{equation}{%s}\n" numberp)
	     (car args)))))
  (apply orig-func args))

(advice-add 'org-create-formula-image :around #'org-renumber-environment)
#+end_src

*** Automatic LaTeX fragment previewing toggle

This solution (found [[http://slumpy.org/blog/2017-02-01-automatic-latex-preview-in-org-mode/][here]]) enables org-mode LaTeX preview images when the cursor is over the equation.
#+begin_src emacs-lisp
(defvar kk/org-latex-fragment-last nil
  "Holds last fragment/environment you were on.")

(defun kk/org-in-latex-fragment-p ()
  "Return the point where the latex fragment begins, if inside
  a latex fragment. Else return false"
  (let* ((el (org-element-context))
	 (el-type (car el)))
    (and (or (eq 'latex-fragment el-type) (eq 'latex-environment el-type))
	 (org-element-property :begin el))))

(defun kk/org-latex-fragment-toggle ()
  "Toggle a latex fragment image "
  (and (eq 'org-mode major-mode)
       (let ((begin (kk/org-in-latex-fragment-p)))
	 (cond
	  ;; were on a fragment and now on a new fragment
	  ((and
	    ;; fragment we were on
	    kk/org-latex-fragment-last
	    ;; and are on a fragment now
	    begin

	    ;; but not on the last one this is a little tricky. as you edit the
	    ;; fragment, it is not equal to the last one. We use the begin
	    ;; property which is less likely to change for the comparison.
	    (not (and kk/org-latex-fragment-last
		      (= begin
			 kk/org-latex-fragment-last))))
	   ;; go back to last one and put image back, provided there is still a fragment there
	   (save-excursion
	     (goto-char kk/org-latex-fragment-last)
	     (when (kk/org-in-latex-fragment-p) (org-preview-latex-fragment))

	     ;; now remove current image
	     (goto-char begin)
	     (let ((ov (loop for ov in (org--list-latex-overlays)
			     if
			     (and
			      (<= (overlay-start ov) (point))
			      (>= (overlay-end ov) (point)))
			     return ov)))
	       (when ov
		 (delete-overlay ov)))
	     ;; and save new fragment
	     (setq kk/org-latex-fragment-last begin)))

	  ;; were on a fragment and now are not on a fragment
	  ((and
	    ;; not on a fragment now
	    (not begin)
	    ;; but we were on one
	    kk/org-latex-fragment-last)
	   ;; put image back on, provided that there is still a fragment here.
	   (save-excursion
	     (goto-char kk/org-latex-fragment-last)
	     (when (kk/org-in-latex-fragment-p) (org-preview-latex-fragment)))

	   ;; unset last fragment
	   (setq kk/org-latex-fragment-last nil))

	  ;; were not on a fragment, and now are
	  ((and
	    ;; we were not one one
	    (not kk/org-latex-fragment-last)
	    ;; but now we are
	    begin)
	   ;; remove image
	   (save-excursion
	     (goto-char begin)
	     (let ((ov (loop for ov in (org--list-latex-overlays)
			     if
			     (and
			      (<= (overlay-start ov) (point))
			      (>= (overlay-end ov) (point)))
			     return ov)))
	       (when ov
		 (delete-overlay ov))))
	   (setq kk/org-latex-fragment-last begin))))))

(add-hook 'post-command-hook 'kk/org-latex-fragment-toggle t)
#+end_src

*** LaTeX code syntax highlighting

#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
#+end_src

*** Quick insertion of LaTeX environment

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

** Babel
:properties:
:header-args+: :noweb-ref org-conf
:header-args+: :tangle no
:end:

*** Preserve leading whitespace on export

#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

*** Load languages

#+begin_src emacs-lisp
;; active Babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (R . t)
   (ruby . t)
   (C . t)
   (python . t)
   (fortran . t)
   (makefile . t)
   (emacs-lisp . nil)))
#+end_src
